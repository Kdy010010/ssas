<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>StarShield: 재의 그림자 — Supercomputer Sprite + EMP x6 + SFX</title>
  <style>
    :root{
      --bg1:#050014; --bg2:#0b1028;
      --accent:#4af2c5; --danger:#ff4b81; --warn:#ffd166;
      --text:#f4f8ff; --sub:#aebcff;
      --panel:rgba(14,20,58,.62);
      --border:rgba(160,190,255,.18);
    }
    html,body{height:100%;margin:0;overflow:hidden;background:var(--bg2);font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif}
    #lockScreen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at top,#23306a 0,#0b1028 62%,#050014 100%);color:var(--text);z-index:10}
    #card{width:min(720px,calc(100% - 24px));background:rgba(16,22,58,.86);border:1px solid rgba(160,190,255,.20);border-radius:18px;padding:18px 18px 16px;box-shadow:0 18px 70px rgba(0,0,0,.55)}
    #card h1{margin:0 0 8px;font-size:18px;letter-spacing:.2px}
    #card p{margin:0 0 10px;color:#d2ddff;font-size:14px;line-height:1.45}
    #card ul{margin:10px 0 0;padding-left:18px;color:#d2ddff;font-size:13px;line-height:1.55}
    #btn{margin-top:14px;width:100%;padding:12px 14px;border-radius:14px;border:1px solid rgba(160,190,255,.28);background:linear-gradient(180deg, rgba(74,242,197,.22), rgba(74,242,197,.10));color:#eafff9;font-weight:900;cursor:pointer}

    #hud{position:fixed;inset:0;pointer-events:none;color:#eaf2ff;text-shadow:0 1px 0 rgba(0,0,0,.35);z-index:5}
    #topbar{position:absolute;left:16px;top:12px;display:flex;gap:10px;align-items:center;font-size:13px;opacity:.98;flex-wrap:wrap;max-width:calc(100vw - 280px)}
    .pill{background:var(--panel);border:1px solid var(--border);padding:8px 10px;border-radius:12px;backdrop-filter: blur(10px);-webkit-backdrop-filter: blur(10px)}
    #hint{position:absolute;left:50%;transform:translateX(-50%);bottom:18px;max-width:min(920px,calc(100% - 24px));background:var(--panel);border:1px solid var(--border);padding:10px 12px;border-radius:14px;font-size:14px;line-height:1.35;opacity:0;transition:opacity .2s;backdrop-filter: blur(10px);-webkit-backdrop-filter: blur(10px)}
    #cross{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:18px;height:18px;opacity:.7}
    #cross::before,#cross::after{content:"";position:absolute;left:50%;top:50%;background:#dfe9ff}
    #cross::before{width:18px;height:2px;transform:translate(-50%,-50%)}
    #cross::after{width:2px;height:18px;transform:translate(-50%,-50%)}
    #vignette{position:absolute;inset:-1px;pointer-events:none;background:radial-gradient(circle at center, rgba(0,0,0,0) 54%, rgba(0,0,0,.62) 100%);opacity:.75}
    #scanlines{
      position:absolute;inset:0;pointer-events:none;opacity:.14;
      background:repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.06) 0px,
        rgba(255,255,255,.06) 1px,
        rgba(0,0,0,0) 3px,
        rgba(0,0,0,0) 6px
      );
      mix-blend-mode:overlay;
    }

    /* Minimap */
    #mapWrap{
      position:absolute;right:14px;top:12px;pointer-events:none;
      background:rgba(10,14,40,.52);
      border:1px solid rgba(160,190,255,.18);
      border-radius:14px;
      padding:10px;
      width:220px;
      box-shadow:0 14px 60px rgba(0,0,0,.55);
      backdrop-filter: blur(10px);-webkit-backdrop-filter: blur(10px);
    }
    #mapTitle{font-size:12px;color:#d2ddff;margin:0 0 8px;display:flex;justify-content:space-between;gap:8px}
    #mapCanvas{width:200px;height:200px;border-radius:10px;background:rgba(5,7,18,.55);display:block}
    #mapLegend{margin-top:8px;font-size:11px;color:#d2ddff;opacity:.92;display:flex;gap:10px;flex-wrap:wrap}
    .dot{display:inline-block;width:10px;height:10px;border-radius:999px;vertical-align:-1px;margin-right:6px}
    .pDot{background:var(--accent)}
    .gDot{background:var(--danger)}
    .eDot{background:var(--warn)}

    /* Message overlay */
    #msgOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none;opacity:0;transition:opacity .25s;z-index:8}
    #msgCard{
      width:min(860px,calc(100% - 24px));
      background:linear-gradient(180deg, rgba(10,12,26,.84), rgba(6,8,18,.86));
      border:1px solid rgba(255,75,129,.30);
      border-radius:18px;
      padding:18px 18px 16px;
      box-shadow:0 18px 90px rgba(0,0,0,.70);
      color:#ffe9f0;
      backdrop-filter: blur(10px);-webkit-backdrop-filter: blur(10px);
      position:relative;
      overflow:hidden;
    }
    #msgCard::before{
      content:"";position:absolute;inset:-40%;
      background:radial-gradient(circle at 30% 20%, rgba(255,75,129,.20), transparent 55%),
                 radial-gradient(circle at 70% 80%, rgba(74,242,197,.14), transparent 60%);
      filter: blur(18px);
      opacity:.85;
      pointer-events:none;
    }
    #msgCard::after{
      content:"";position:absolute;inset:0;
      background:repeating-linear-gradient(to bottom, rgba(255,255,255,.06) 0px, rgba(255,255,255,.06) 1px, rgba(0,0,0,0) 4px, rgba(0,0,0,0) 8px);
      opacity:.12;
      pointer-events:none;
      mix-blend-mode:overlay;
    }
    #msgCard pre{position:relative;margin:0;white-space:pre-wrap;word-break:break-word;font-size:14px;line-height:1.5}
    .redBlink{color:var(--danger);font-weight:900;animation:blink .9s infinite}
    @keyframes blink{0%,48%{opacity:1} 50%,100%{opacity:.35}}

    #fade{position:fixed;inset:0;background:#000;pointer-events:none;opacity:0;transition:opacity 1.2s;z-index:9}
    #endTitle{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;color:#eaf2ff;text-align:center;pointer-events:none;opacity:0;transition:opacity 1.2s;z-index:9}
    #endTitle .inner{width:min(860px,calc(100% - 24px));padding:22px;border-radius:20px;background:rgba(16,22,58,.55);border:1px solid rgba(160,190,255,.14);box-shadow:0 18px 70px rgba(0,0,0,.55);backdrop-filter: blur(10px);-webkit-backdrop-filter: blur(10px)}
    #endTitle h2{margin:0 0 10px;font-size:22px;letter-spacing:.2px}
    #endTitle p{margin:0;color:#d2ddff;font-size:14px;line-height:1.55}

 /* Mobile controls (Improved UX) */
#mobileUI{position:fixed;inset:0;pointer-events:none;z-index:6}

/* safe-area helper */
:root{
  --safeB: env(safe-area-inset-bottom, 0px);
  --safeL: env(safe-area-inset-left, 0px);
  --safeR: env(safe-area-inset-right, 0px);
}

/* Smaller joystick, bottom-left, not blocking view */
.joy{
  position:absolute;
  left:calc(12px + var(--safeL));
  bottom:calc(12px + var(--safeB));
  width:118px;height:118px;border-radius:999px;
  background:radial-gradient(circle at 30% 30%, rgba(74,242,197,.14), rgba(10,14,40,.10));
  border:1px solid rgba(160,190,255,.18);
  box-shadow:0 14px 50px rgba(0,0,0,.40);
  backdrop-filter: blur(10px);-webkit-backdrop-filter: blur(10px);
  pointer-events:auto;
  touch-action:none;
  display:none;
  opacity:.92;
}
.joy::after{content:"";position:absolute;inset:10px;border-radius:999px;border:1px dashed rgba(160,190,255,.22);opacity:.7}

#stick{
  position:absolute;left:50%;top:50%;
  width:54px;height:54px;border-radius:999px;
  transform:translate(-50%,-50%);
  background:radial-gradient(circle at 30% 30%, rgba(255,255,255,.16), rgba(74,242,197,.10));
  border:1px solid rgba(74,242,197,.26);
  box-shadow:0 10px 34px rgba(0,0,0,.38), 0 0 34px rgba(74,242,197,.14);
}

/* Remove the big look pad: we will use right-half screen drag */
.rightLook{display:none !important}

/* Buttons in one row, bottom-right */
.btns{
  position:absolute;
  right:calc(12px + var(--safeR));
  bottom:calc(12px + var(--safeB));
  display:flex;
  flex-direction:row;
  gap:10px;
  pointer-events:auto;
  touch-action:none;
  display:none;
}
.mBtn{
  width:74px;height:52px;border-radius:16px;
  background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(10,14,40,.22));
  border:1px solid rgba(160,190,255,.20);
  color:#eaf2ff;font-weight:900;
  display:flex;align-items:center;justify-content:center;
  box-shadow:0 14px 48px rgba(0,0,0,.40);
  backdrop-filter: blur(10px);-webkit-backdrop-filter: blur(10px);
  user-select:none;-webkit-user-select:none;
}
.mBtn.danger{border-color:rgba(255,75,129,.24)}
.mBtn.accent{border-color:rgba(74,242,197,.24)}
.mBtn.warn{border-color:rgba(255,209,102,.24)}

/* Minimap default: collapsed button mode on mobile */
@media (pointer:coarse){
  .joy,.btns{display:flex}
  .joy{display:block}

  /* Map becomes a popup overlay instead of always on */
  #mapWrap{
    width:min(86vw, 360px);
    right:calc(12px + var(--safeR));
    top:calc(12px + env(safe-area-inset-top, 0px));
    transform: translateY(-10px);
    opacity:0;
    pointer-events:none;
    transition:opacity .18s, transform .18s;
  }
  #mapWrap.open{
    opacity:1;
    pointer-events:auto;
    transform: translateY(0);
  }
  #mapCanvas{width:100%;height:auto;aspect-ratio:1/1}
}

  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="lockScreen">
    <div id="card">
      <h1>StarShield: 재의 그림자</h1>
      <p>
        시작부터 <b>미로 내부</b>. 1층 <b>3명</b>, 2층 <b>2명</b> 경비 유닛이 <b>A*</b>로 추격합니다.<br/>
        <b>EMP(F)</b>: <b>전체 층의 모든 경비 5초 기절</b> (총 <b>6회</b>).
      </p>
      <ul>
        <li>PC: WASD 이동 / 마우스 시점 / Shift 달리기 / E 상호작용 / <b>F EMP</b> / R 리셋</li>
        <li>모바일: 왼쪽 조이스틱 이동 + 오른쪽 드래그 시점 + 버튼(E/Run/EMP/R)</li>
      </ul>
      <button id="btn">시작 (클릭)</button>
    </div>
  </div>

  <canvas id="c"></canvas>

  <div id="hud">
    <div id="topbar">
      <div class="pill" id="status">STATUS: 침투</div>
      <div class="pill" id="floor">FLOOR: 1</div>
      <div class="pill" id="alert">ALERT: 0%</div>
      <div class="pill" id="empHud">EMP: 6</div>
    </div>

    <div id="mapWrap">
      <div id="mapTitle">
        <span id="mapFloor">MAP: FLOOR 1</span>
        <span style="opacity:.85">N ↑</span>
      </div>
      <canvas id="mapCanvas" width="200" height="200"></canvas>
      <div id="mapLegend">
        <span><i class="dot pDot"></i>플레이어</span>
        <span><i class="dot gDot"></i>경비</span>
        <span><i class="dot eDot"></i>목표</span>
      </div>
    </div>

    <div id="cross"></div>
    <div id="hint"></div>
    <div id="vignette"></div>
    <div id="scanlines"></div>
  </div>

  <div id="mobileUI">
    <div class="joy" id="joy"><div id="stick"></div></div>
    <div class="rightLook" id="lookPad"></div>
    <div class="btns" id="btns">
      <div class="mBtn accent" id="btnE">E</div>
      <div class="mBtn" id="btnRun">RUN</div>
      <div class="mBtn warn" id="btnEMP">EMP</div>
      <div class="mBtn danger" id="btnR">R</div>
    </div>
  </div>

  <div id="msgOverlay">
    <div id="msgCard"><pre id="msgText"></pre></div>
  </div>

  <div id="fade"></div>
  <div id="endTitle">
    <div class="inner">
      <h2 id="endH">…몇 분 후, 이곳에는 <span class="redBlink">재와 그림자</span>만 남았습니다.</h2>
      <p id="endP">즉사 엔딩(프로토타입).<br/>R 키로 다시 시작할 수 있습니다.</p>
    </div>
  </div>

<script type="module">
import * as THREE from "three";
import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";

/* =========================
   Config
========================= */
const floors = 5;
const floorHeight = 4.2;
const cellSize = 1.45;
const gridW = 25, gridH = 25;

const wallHeight = 2.7;
const slabThickness = 0.7;
const ceilingThickness = 0.65;

const PLAYER_RADIUS = 0.33;
const PLAYER_EYE = 1.65;

const DEATH_DIST = 0.62;

// EMP: 전체 경비 5초 / 6회
const EMP_MAX = 6;          // ✅ 6개
const EMP_STUN_SEC = 5.0;
const EMP_COOLDOWN = 0.55;

/* =========================
   DOM
========================= */
const canvas = document.getElementById("c");
const lockScreen = document.getElementById("lockScreen");
const btn = document.getElementById("btn");
const hint = document.getElementById("hint");
const statusEl = document.getElementById("status");
const floorEl  = document.getElementById("floor");
const alertEl  = document.getElementById("alert");
const empHud   = document.getElementById("empHud");
const msgOverlay = document.getElementById("msgOverlay");
const msgText = document.getElementById("msgText");
const fade = document.getElementById("fade");
const endTitle = document.getElementById("endTitle");
const endH = document.getElementById("endH");
const endP = document.getElementById("endP");

const mapCanvas = document.getElementById("mapCanvas");
const mapCtx = mapCanvas.getContext("2d");
const mapFloorEl = document.getElementById("mapFloor");

/* Mobile UI */
const isMobile = matchMedia("(pointer:coarse)").matches;
const joy = document.getElementById("joy");
const stick = document.getElementById("stick");
const lookPad = document.getElementById("lookPad");
const btnE = document.getElementById("btnE");
const btnRun = document.getElementById("btnRun");
const btnEMP = document.getElementById("btnEMP");
const btnR = document.getElementById("btnR");

/* =========================
   Renderer / Scene / Camera
========================= */
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b1028);
scene.fog = new THREE.FogExp2(0x0b1028, 0.018);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.08, 600);
camera.position.set(0, PLAYER_EYE, 0);

const controls = new PointerLockControls(camera, document.body);
scene.add(controls.getObject());

/* =========================
   Lighting
========================= */
scene.add(new THREE.HemisphereLight(0xcfe0ff, 0x1a2040, 1.10));
const dir = new THREE.DirectionalLight(0xffffff, 1.05);
dir.position.set(12, 22, 10);
scene.add(dir);

/* =========================
   Audio (WebAudio SFX)
========================= */
let audioCtx = null;
let masterGain = null;

function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.42;
  masterGain.connect(audioCtx.destination);
}
function nowA(){ return audioCtx.currentTime; }
function playNoise({dur=0.25, hp=700, lp=6000, gain=0.25, curve=0.0008}={}){
  if(!audioCtx) return;
  const t0 = nowA();

  const bufferSize = Math.max(1, Math.floor(audioCtx.sampleRate * dur));
  const buf = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for(let i=0;i<bufferSize;i++){
    const n = (Math.random()*2-1);
    data[i] = n * (1 - i/bufferSize);
  }
  const src = audioCtx.createBufferSource();
  src.buffer = buf;

  const hpF = audioCtx.createBiquadFilter();
  hpF.type = "highpass"; hpF.frequency.value = hp;
  const lpF = audioCtx.createBiquadFilter();
  lpF.type = "lowpass"; lpF.frequency.value = lp;

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.0001, t0);
  g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

  src.connect(hpF); hpF.connect(lpF); lpF.connect(g); g.connect(masterGain);
  src.start(t0);
  src.stop(t0 + dur + 0.02);
}
function playTone({freq=220, dur=0.25, type="sawtooth", gain=0.2, detune=0}={}){
  if(!audioCtx) return;
  const t0 = nowA();
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, t0);
  osc.detune.setValueAtTime(detune, t0);

  g.gain.setValueAtTime(0.0001, t0);
  g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

  osc.connect(g); g.connect(masterGain);
  osc.start(t0);
  osc.stop(t0 + dur + 0.02);
}
function sfxEMP(){
  if(!audioCtx) return;
  playNoise({dur:0.22, hp:800, lp:9000, gain:0.28});
  playTone({freq:140, dur:0.18, type:"square", gain:0.16});
  playTone({freq:520, dur:0.10, type:"sawtooth", gain:0.10, detune:-14});
}
function sfxCaught(){
  if(!audioCtx) return;
  // alarm sweep
  const t0 = nowA();
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type="square";
  osc.frequency.setValueAtTime(520, t0);
  osc.frequency.exponentialRampToValueAtTime(980, t0+0.25);
  osc.frequency.exponentialRampToValueAtTime(520, t0+0.5);
  g.gain.setValueAtTime(0.0001, t0);
  g.gain.exponentialRampToValueAtTime(0.22, t0+0.02);
  g.gain.exponentialRampToValueAtTime(0.0001, t0+0.62);
  osc.connect(g); g.connect(masterGain);
  osc.start(t0); osc.stop(t0+0.65);

  // thump + noise
  playTone({freq:70, dur:0.35, type:"sine", gain:0.22});
  playNoise({dur:0.28, hp:120, lp:2500, gain:0.18});
}
function sfxMissionOver(){
  if(!audioCtx) return;
  playTone({freq:240, dur:0.18, type:"sawtooth", gain:0.12});
  playTone({freq:120, dur:0.26, type:"triangle", gain:0.10});
  playNoise({dur:0.22, hp:300, lp:5000, gain:0.16});
}

/* =========================
   Helpers
========================= */
function showHint(text, visible=true){
  hint.textContent = text;
  hint.style.opacity = visible ? "1" : "0";
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function dist2xz(a,b){ const dx=a.x-b.x, dz=a.z-b.z; return dx*dx + dz*dz; }
function distxz(a,b){ return Math.hypot(a.x-b.x, a.z-b.z); }
function mulberry32(seed){
  let t = seed >>> 0;
  return function(){
    t += 0x6D2B79F5;
    let x = Math.imul(t ^ (t >>> 15), 1 | t);
    x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
    return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
  };
}
function currentFloorIndexFromY(y){
  return Math.max(0, Math.min(floors-1, Math.floor((y + 0.001) / floorHeight)));
}

/* =========================
   Procedural Hi-Tech Textures
========================= */
function makeHiTechTexture({size=512, seed=1, glow="#4af2c5"}={}){
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const g = c.getContext("2d");

  g.fillStyle = "#0b0f26";
  g.fillRect(0,0,size,size);

  const rnd = mulberry32(9000 + seed);
  const img = g.getImageData(0,0,size,size);
  for(let i=0;i<img.data.length;i+=4){
    const n = (rnd()*18)|0;
    img.data[i+0] += n; img.data[i+1] += n; img.data[i+2] += n; img.data[i+3] = 255;
  }
  g.putImageData(img,0,0);

  g.strokeStyle = "rgba(160,190,255,0.18)";
  g.lineWidth = 2;
  const step = 64;
  for(let x=0;x<=size;x+=step){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,size); g.stroke(); }
  for(let y=0;y<=size;y+=step){ g.beginPath(); g.moveTo(0,y); g.lineTo(size,y); g.stroke(); }

  g.fillStyle = "rgba(210,221,255,0.22)";
  for(let y=step/2;y<size;y+=step){
    for(let x=step/2;x<size;x+=step){
      g.beginPath(); g.arc(x-22,y-22,3,0,Math.PI*2); g.fill();
      g.beginPath(); g.arc(x+22,y+22,3,0,Math.PI*2); g.fill();
    }
  }

  g.strokeStyle = "rgba(74,242,197,0.35)";
  g.lineWidth = 3;
  for(let i=0;i<10;i++){
    const yy = ((rnd()*size)|0);
    g.beginPath(); g.moveTo(0,yy); g.lineTo(size,yy + ((rnd()*80)-40)); g.stroke();
  }
  g.strokeStyle = "rgba(255,75,129,0.22)";
  for(let i=0;i<6;i++){
    const xx = ((rnd()*size)|0);
    g.beginPath(); g.moveTo(xx,0); g.lineTo(xx + ((rnd()*80)-40), size); g.stroke();
  }

  const grd = g.createLinearGradient(0,0,size,0);
  grd.addColorStop(0, "rgba(0,0,0,0)");
  grd.addColorStop(0.5, glow);
  grd.addColorStop(1, "rgba(0,0,0,0)");
  g.fillStyle = grd;
  g.globalAlpha = 0.18;
  g.fillRect(0,size*0.42,size,size*0.08);
  g.globalAlpha = 1;

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(2.2, 2.2);
  tex.anisotropy = 8;
  return tex;
}

function makeFloorTexture({size=512, seed=2}={}){
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const g = c.getContext("2d");
  g.fillStyle = "#0d1436";
  g.fillRect(0,0,size,size);

  g.strokeStyle = "rgba(160,190,255,0.16)";
  g.lineWidth = 2;
  const step = 64;
  for(let x=0;x<=size;x+=step){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,size); g.stroke(); }
  for(let y=0;y<=size;y+=step){ g.beginPath(); g.moveTo(0,y); g.lineTo(size,y); g.stroke(); }

  g.strokeStyle = "rgba(74,242,197,0.28)";
  g.lineWidth = 4;
  g.beginPath(); g.moveTo(size*0.1, size*0.5); g.lineTo(size*0.9, size*0.5); g.stroke();

  g.strokeStyle = "rgba(255,209,102,0.20)";
  g.lineWidth = 3;
  g.setLineDash([16,10]);
  g.beginPath(); g.moveTo(size*0.1, size*0.62); g.lineTo(size*0.9, size*0.62); g.stroke();
  g.setLineDash([]);

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(3.2, 3.2);
  tex.anisotropy = 8;
  return tex;
}

const wallTex = makeHiTechTexture({seed:11, glow:"rgba(74,242,197,0.55)"});
const floorTex = makeFloorTexture({seed:22});
const ceilTex = makeHiTechTexture({seed:33, glow:"rgba(255,75,129,0.35)"});

/* =========================
   Materials
========================= */
const matWall = new THREE.MeshStandardMaterial({
  color: 0xffffff,
  map: wallTex,
  roughness: 0.55,
  metalness: 0.35,
  emissive: new THREE.Color(0x001018),
  emissiveIntensity: 0.25
});
const matTrim = new THREE.MeshStandardMaterial({
  color: 0x26307a, roughness:0.45, metalness:0.65
});
const matFloor = new THREE.MeshStandardMaterial({
  color: 0xffffff,
  map: floorTex,
  roughness: 0.80,
  metalness: 0.10,
  emissive: new THREE.Color(0x001018),
  emissiveIntensity: 0.12
});
const matCeil = new THREE.MeshStandardMaterial({
  color: 0xffffff,
  map: ceilTex,
  roughness: 0.80,
  metalness: 0.10,
  emissive: new THREE.Color(0x110015),
  emissiveIntensity: 0.12
});

/* =========================
   Supercomputer Sprite (Billboard)
========================= */
function makeSuperComputerSprite(){
  const c = document.createElement("canvas");
  c.width = 512; c.height = 512;
  const g = c.getContext("2d");

  // bg
  g.fillStyle = "rgba(4,6,16,0.0)";
  g.fillRect(0,0,512,512);

  // hologram plate
  const grd = g.createLinearGradient(0,0,512,512);
  grd.addColorStop(0, "rgba(74,242,197,0.18)");
  grd.addColorStop(0.55, "rgba(160,190,255,0.10)");
  grd.addColorStop(1, "rgba(255,75,129,0.10)");
  g.fillStyle = grd;
  roundRect(g, 46, 78, 420, 356, 24, true, false);

  // grid lines
  g.strokeStyle = "rgba(210,221,255,0.16)";
  g.lineWidth = 2;
  for(let x=80;x<460;x+=40){
    g.beginPath(); g.moveTo(x,110); g.lineTo(x,410); g.stroke();
  }
  for(let y=110;y<430;y+=40){
    g.beginPath(); g.moveTo(80,y); g.lineTo(460,y); g.stroke();
  }

  // title
  g.font = "800 38px system-ui,Segoe UI,Apple SD Gothic Neo,Noto Sans KR,sans-serif";
  g.fillStyle = "rgba(234,255,249,0.92)";
  g.fillText("KOROLYOV V2", 92, 160);

  // subtitle
  g.font = "700 18px system-ui,Segoe UI,Apple SD Gothic Neo,Noto Sans KR,sans-serif";
  g.fillStyle = "rgba(210,221,255,0.88)";
  g.fillText("COMMUNIST CORE / SUPERCOMPUTER", 94, 195);

  // fake “status” lines
  g.font = "600 16px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";
  g.fillStyle = "rgba(74,242,197,0.85)";
  const lines = [
    "NODE GRID:   ACTIVE",
    "THERMALS:    NOMINAL",
    "SECURITY:    ARMED",
    "LOG PURGE:   PENDING"
  ];
  let yy=250;
  for(const L of lines){
    g.fillText(L, 94, yy);
    yy += 34;
  }

  // warning
  g.fillStyle = "rgba(255,75,129,0.85)";
  g.fillText("INTRUSION FLAG: TRUE", 94, 390);

  // frame
  g.strokeStyle = "rgba(74,242,197,0.32)";
  g.lineWidth = 4;
  roundRect(g, 46, 78, 420, 356, 24, false, true);

  // glow edge
  g.shadowColor = "rgba(74,242,197,0.55)";
  g.shadowBlur = 18;
  g.strokeStyle = "rgba(74,242,197,0.25)";
  g.lineWidth = 3;
  roundRect(g, 52, 84, 408, 344, 22, false, true);

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.needsUpdate = true;

  const mat = new THREE.SpriteMaterial({
    map: tex,
    transparent: true,
    opacity: 0.98,
    depthWrite: false,
    depthTest: true
  });

  const spr = new THREE.Sprite(mat);
  spr.scale.set(3.6, 3.6, 1);
  spr.userData = { isSuperComputer:true };
  return spr;

  function roundRect(ctx,x,y,w,h,r,fill,stroke){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }
}

/* =========================
   Maze generation
========================= */
function makeMazeGrid(w, h, rand){
  const grid = Array.from({length:h}, () => Array(w).fill(1));
  const dirs = [[2,0],[-2,0],[0,2],[0,-2]];
  const sx=1, sy=1;

  const shuffle = (arr)=>{
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(rand()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  };

  const carve=(x,y)=> grid[y][x]=0;
  carve(sx,sy);

  const stack=[[sx,sy]];
  while(stack.length){
    const [cx,cy]=stack[stack.length-1];
    const nbs=[];
    for(const [dx,dy] of dirs){
      const nx=cx+dx, ny=cy+dy;
      if(nx>0 && ny>0 && nx<w-1 && ny<h-1 && grid[ny][nx]===1) nbs.push([nx,ny,dx,dy]);
    }
    if(!nbs.length){ stack.pop(); continue; }
    shuffle(nbs);
    const [nx,ny,dx,dy]=nbs[0];
    carve(cx+dx/2, cy+dy/2);
    carve(nx,ny);
    stack.push([nx,ny]);
  }

  grid[1][0]=0;
  grid[h-2][w-1]=0;
  return grid;
}

/* =========================
   World building
========================= */
const world = new THREE.Group();
scene.add(world);

const floorInfos = [];
const colliders = [];

function addAABBCollider(mesh){
  colliders.push({ mesh, box: new THREE.Box3().setFromObject(mesh) });
}
function cellToWorld(cx, cy, yBase){
  const x = (cx - (gridW-1)/2) * cellSize;
  const z = (cy - (gridH-1)/2) * cellSize;
  return new THREE.Vector3(x, yBase + 0.0, z);
}
function worldToCell(pos){
  const cx = Math.round(pos.x / cellSize + (gridW-1)/2);
  const cy = Math.round(pos.z / cellSize + (gridH-1)/2);
  return { x: Math.max(0, Math.min(gridW-1, cx)), y: Math.max(0, Math.min(gridH-1, cy)) };
}
function makeRingMarker(color){
  const ring = new THREE.Mesh(
    new THREE.RingGeometry(1.05, 1.4, 36),
    new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.85, side:THREE.DoubleSide })
  );
  ring.rotation.x = -Math.PI/2;
  return ring;
}

let superComputerSprite = null; // ✅ created on final floor

function buildOneFloor(fIndex){
  const g = new THREE.Group();
  const yBase = fIndex * floorHeight;

  const slab = new THREE.Mesh(
    new THREE.BoxGeometry(gridW*cellSize, slabThickness, gridH*cellSize),
    matFloor
  );
  slab.position.set(0, yBase - slabThickness/2, 0);
  g.add(slab);

  if(fIndex < floors-1){
    const ceil = new THREE.Mesh(
      new THREE.BoxGeometry(gridW*cellSize, ceilingThickness, gridH*cellSize),
      matCeil
    );
    ceil.position.set(0, yBase + floorHeight - ceilingThickness/2, 0);
    g.add(ceil);
  }

  const rand = mulberry32(12345 + fIndex*999);
  const grid = makeMazeGrid(gridW, gridH, rand);

  const wallGeom = new THREE.BoxGeometry(cellSize, wallHeight, cellSize);

  for(let y=0;y<gridH;y++){
    for(let x=0;x<gridW;x++){
      if(grid[y][x]===1){
        const wall = new THREE.Mesh(wallGeom, matWall);
        wall.position.copy(cellToWorld(x,y,yBase)).add(new THREE.Vector3(0, wallHeight/2, 0));
        g.add(wall);

        const cap = new THREE.Mesh(new THREE.BoxGeometry(cellSize*1.02, 0.12, cellSize*1.02), matTrim);
        cap.position.copy(wall.position).add(new THREE.Vector3(0, wallHeight/2 + 0.06, 0));
        g.add(cap);

        addAABBCollider(wall);
      }
    }
  }

  const light = new THREE.PointLight(0xbad6ff, 1.05, 44, 2.1);
  light.position.set(0, yBase + 2.5, 0);
  g.add(light);

  const entranceCell = { x:0, y:1 };
  const exitCell = { x:gridW-1, y:gridH-2 };
  const entrancePos = cellToWorld(entranceCell.x, entranceCell.y, yBase);
  const exitPos = cellToWorld(exitCell.x, exitCell.y, yBase);

  let exitMarker = null;
  if(fIndex < floors-1){
    exitMarker = makeRingMarker(0x4af2c5);
    exitMarker.position.copy(exitPos).setY(yBase + 0.08);
    g.add(exitMarker);
  }

  let bombPos=null, bombMarker=null;
  if(fIndex === floors-1){
    const cx = Math.floor(gridW/2), cy = Math.floor(gridH/2);
    let found=null;
    for(let r=0;r<Math.max(gridW,gridH) && !found;r++){
      for(let dy=-r;dy<=r;dy++){
        for(let dx=-r;dx<=r;dx++){
          const xx=cx+dx, yy=cy+dy;
          if(xx>=0&&yy>=0&&xx<gridW&&yy<gridH && grid[yy][xx]===0){ found={x:xx,y:yy}; break; }
        }
        if(found) break;
      }
    }
    bombPos = cellToWorld(found.x, found.y, yBase);
    bombMarker = makeRingMarker(0xffd166);
    bombMarker.position.copy(bombPos).setY(yBase + 0.08);
    g.add(bombMarker);

    // ✅ Supercomputer sprite near bomb position
    superComputerSprite = makeSuperComputerSprite();
    superComputerSprite.position.copy(bombPos);
    superComputerSprite.position.y = yBase + 1.65;
    superComputerSprite.position.x += 0.9;
    superComputerSprite.position.z -= 0.6;
    g.add(superComputerSprite);

    // little glow light to sell it
    const holo = new THREE.PointLight(0x4af2c5, 0.95, 9.5, 2.3);
    holo.position.copy(superComputerSprite.position).add(new THREE.Vector3(0, 0.15, 0));
    g.add(holo);
    superComputerSprite.userData.holoLight = holo;
  }

  world.add(g);
  floorInfos.push({
    index: fIndex, yBase, grid,
    entrancePos, exitPos, exitRadius: 1.9, exitMarker,
    bombPos, bombRadius: 2.1, bombMarker
  });
}

for(let i=0;i<floors;i++) buildOneFloor(i);

/* =========================
   Player collision
========================= */
function resolveCollisions(pos){
  const radius = PLAYER_RADIUS;
  const p = pos.clone();
  const pb = new THREE.Box3(
    new THREE.Vector3(p.x - radius, p.y, p.z - radius),
    new THREE.Vector3(p.x + radius, p.y + 1.8, p.z + radius)
  );

  for(const c of colliders){
    if(!pb.intersectsBox(c.box)) continue;

    const cb = c.box;
    const overlapX = Math.min(pb.max.x, cb.max.x) - Math.max(pb.min.x, cb.min.x);
    const overlapZ = Math.min(pb.max.z, cb.max.z) - Math.max(pb.min.z, cb.min.z);

    if(overlapX > 0 && overlapZ > 0){
      if(overlapX < overlapZ){
        const dir = (p.x < (cb.min.x + cb.max.x)/2) ? -1 : 1;
        p.x += dir * (overlapX + 0.001);
      }else{
        const dir = (p.z < (cb.min.z + cb.max.z)/2) ? -1 : 1;
        p.z += dir * (overlapZ + 0.001);
      }
      pb.min.set(p.x - radius, pb.min.y, p.z - radius);
      pb.max.set(p.x + radius, pb.max.y, p.z + radius);
    }
  }
  return p;
}

/* =========================
   A* pathfinding
========================= */
function keyOf(x,y){ return x + "," + y; }
function aStar(grid, start, goal){
  const W = grid[0].length, H = grid.length;
  const sx=start.x, sy=start.y, gx=goal.x, gy=goal.y;
  if(grid[sy][sx]===1 || grid[gy][gx]===1) return [];

  const open = new Map();
  const cameFrom = new Map();
  const gScore = new Map();
  const fScore = new Map();
  const h = (x,y)=> Math.abs(x-gx) + Math.abs(y-gy);

  const startK = keyOf(sx,sy);
  gScore.set(startK, 0);
  fScore.set(startK, h(sx,sy));
  open.set(startK, {x:sx,y:sy});

  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

  function popLowestF(){
    let bestK=null, bestF=Infinity;
    for(const k of open.keys()){
      const f = fScore.get(k) ?? Infinity;
      if(f < bestF){ bestF=f; bestK=k; }
    }
    if(!bestK) return null;
    const n = open.get(bestK);
    open.delete(bestK);
    return { ...n, k: bestK };
  }

  while(open.size){
    const cur = popLowestF();
    if(!cur) break;
    if(cur.x===gx && cur.y===gy){
      const path=[{x:gx,y:gy}];
      let ck = cur.k;
      while(cameFrom.has(ck)){
        ck = cameFrom.get(ck);
        const [px,py] = ck.split(",").map(Number);
        path.push({x:px,y:py});
      }
      path.reverse();
      return path;
    }
    const curG = gScore.get(cur.k) ?? Infinity;

    for(const [dx,dy] of dirs){
      const nx=cur.x+dx, ny=cur.y+dy;
      if(nx<0||ny<0||nx>=W||ny>=H) continue;
      if(grid[ny][nx]===1) continue;

      const nk = keyOf(nx,ny);
      const tentative = curG + 1;
      const old = gScore.get(nk);
      if(old === undefined || tentative < old){
        cameFrom.set(nk, cur.k);
        gScore.set(nk, tentative);
        fScore.set(nk, tentative + h(nx,ny));
        if(!open.has(nk)) open.set(nk, {x:nx,y:ny});
      }
    }
  }
  return [];
}

/* =========================
   Guard bot (procedural)
========================= */
function makeGuardBot(){
  const g = new THREE.Group();

  const bodyMat = new THREE.MeshStandardMaterial({
    color: 0x101a4a, roughness:0.35, metalness:0.55, emissive:0x000000, emissiveIntensity:0.0
  });
  const trimMat = new THREE.MeshStandardMaterial({
    color: 0x26307a, roughness:0.45, metalness:0.65, emissive:0x000000, emissiveIntensity:0.0
  });
  const glowMat = new THREE.MeshStandardMaterial({
    color: 0x1b1f3e, roughness:0.15, metalness:0.2, emissive:0xff4b81, emissiveIntensity:1.1
  });

  const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.18, 0.24, 6, 10), bodyMat);
  body.position.y = 0.28; g.add(body);

  const head = new THREE.Mesh(new THREE.SphereGeometry(0.15, 18, 14), trimMat);
  head.position.y = 0.56; g.add(head);

  const core = new THREE.Mesh(new THREE.SphereGeometry(0.09, 18, 14), glowMat);
  core.position.y = 0.40; g.add(core);

  const ring = new THREE.Mesh(new THREE.TorusGeometry(0.26, 0.035, 12, 28), trimMat);
  ring.position.y = 0.42; ring.rotation.x = Math.PI/2; g.add(ring);

  const ant = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.02, 0.22, 10), trimMat);
  ant.position.y = 0.78; g.add(ant);

  const tip = new THREE.Mesh(new THREE.SphereGeometry(0.03, 12, 10), glowMat);
  tip.position.y = 0.90; g.add(tip);

  const pl = new THREE.PointLight(0xff4b81, 0.65, 4.2, 2.0);
  pl.position.set(0, 0.45, 0);
  g.add(pl);

  g.userData = { isGuard:true, mats:[bodyMat, trimMat, glowMat], glowLight: pl };
  return g;
}

/* =========================
   Guards
========================= */
const guards = [];

function pickRandomPathCell(grid, rand, avoidCells=[]){
  const W=grid[0].length, H=grid.length;
  for(let t=0;t<4000;t++){
    const x = Math.floor(rand()*W);
    const y = Math.floor(rand()*H);
    if(grid[y][x]!==0) continue;
    let ok=true;
    for(const a of avoidCells){ if(a.x===x && a.y===y){ ok=false; break; } }
    if(ok) return {x,y};
  }
  return {x:1,y:1};
}
function clearGuards(){
  for(const g of guards) scene.remove(g.obj);
  guards.length = 0;
}
function spawnGuardsExact(){
  clearGuards();
  const plan = [
    { floor: 0, count: 3, seed: 901 },
    { floor: 1, count: 2, seed: 902 }
  ];
  for(const p of plan){
    const info = floorInfos[p.floor];
    const rand = mulberry32(p.seed);
    const avoid = [worldToCell(info.entrancePos)];

    for(let i=0;i<p.count;i++){
      const cell = pickRandomPathCell(info.grid, rand, avoid);
      avoid.push(cell);

      const obj = makeGuardBot();
      const wp = cellToWorld(cell.x, cell.y, info.yBase);
      obj.position.copy(wp);
      obj.position.y = info.yBase;

      scene.add(obj);

      guards.push({
        obj,
        floor: p.floor,
        path: [],
        pathI: 0,
        repathT: 0,
        speed: 3.15,
        alert: 0,
        bob: Math.random()*10,
        stunnedUntil: 0
      });
    }
  }
}

/* =========================
   Inputs
========================= */
const key = new Set();
window.addEventListener("keydown", (e)=>{
  key.add(e.code);
  if(e.code==="KeyR") resetRun();
  if(e.code==="KeyF") useEMP();
});
window.addEventListener("keyup", (e)=> key.delete(e.code));

let joyActive = false;
let joyCenter = {x:0,y:0};
let joyVec = {x:0,y:0};
const JOY_MAX = 52;

function setStick(x,y){
  const len = Math.hypot(x,y);
  let nx=x, ny=y;
  if(len > JOY_MAX){ const s = JOY_MAX/len; nx*=s; ny*=s; }
  stick.style.transform = `translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px))`;
  joyVec.x = nx / JOY_MAX;
  joyVec.y = ny / JOY_MAX;
}
function resetStick(){
  stick.style.transform = "translate(-50%,-50%)";
  joyVec.x = 0; joyVec.y = 0;
}
function clientXY(e){
  const t = (e.touches && e.touches[0]) ? e.touches[0] : e;
  return {x:t.clientX, y:t.clientY};
}

if(isMobile){
  document.body.style.touchAction = "none";

  joy.addEventListener("pointerdown", (e)=>{
    joy.setPointerCapture(e.pointerId);
    joyActive = true;
    const r = joy.getBoundingClientRect();
    joyCenter = { x: r.left + r.width/2, y: r.top + r.height/2 };
    const p = clientXY(e);
    setStick(p.x - joyCenter.x, p.y - joyCenter.y);
  });
  joy.addEventListener("pointermove", (e)=>{
    if(!joyActive) return;
    const p = clientXY(e);
    setStick(p.x - joyCenter.x, p.y - joyCenter.y);
  });
  joy.addEventListener("pointerup", ()=>{ joyActive = false; resetStick(); });
  joy.addEventListener("pointercancel", ()=>{ joyActive = false; resetStick(); });

  let lookActive=false, lastLook={x:0,y:0};
  lookPad.addEventListener("pointerdown", (e)=>{
    lookPad.setPointerCapture(e.pointerId);
    lookActive=true;
    lastLook = clientXY(e);
  });
  lookPad.addEventListener("pointermove", (e)=>{
    if(!lookActive) return;
    const p = clientXY(e);
    const dx = p.x - lastLook.x;
    const dy = p.y - lastLook.y;
    lastLook = p;

    const yaw = -dx * 0.0032;
    const pitch = -dy * 0.0028;
    controls.getObject().rotation.y += yaw;

    camera.rotation.x += pitch;
    camera.rotation.x = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, camera.rotation.x));
  });
  lookPad.addEventListener("pointerup", ()=>{ lookActive=false; });
  lookPad.addEventListener("pointercancel", ()=>{ lookActive=false; });

  btnE.addEventListener("pointerdown", ()=> tryUseE());
  btnR.addEventListener("pointerdown", ()=> resetRun());
  btnEMP.addEventListener("pointerdown", ()=> useEMP());
  btnRun.addEventListener("pointerdown", ()=> key.add("ShiftLeft"));
  btnRun.addEventListener("pointerup",   ()=> key.delete("ShiftLeft"));
  btnRun.addEventListener("pointercancel",()=> key.delete("ShiftLeft"));
}

/* =========================
   Player update
========================= */
let globalAlert = 0;

function updatePlayer(dt){
  const obj = controls.getObject();

  const run = key.has("ShiftLeft") || key.has("ShiftRight");
  const speed = run ? 6.2 : 3.9;

  const forward = new THREE.Vector3();
  camera.getWorldDirection(forward);
  forward.y = 0; forward.normalize();
  const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).multiplyScalar(-1);

  let mvx = 0, mvz = 0;
  if(key.has("KeyW")) mvz += 1;
  if(key.has("KeyS")) mvz -= 1;
  if(key.has("KeyD")) mvx += 1;
  if(key.has("KeyA")) mvx -= 1;

  if(isMobile){
    mvx += joyVec.x;
    mvz += -joyVec.y;
  }

  const dirV = new THREE.Vector3();
  dirV.addScaledVector(right, mvx);
  dirV.addScaledVector(forward, mvz);

  if(dirV.lengthSq() > 1e-6) dirV.normalize();

  const vel = dirV.multiplyScalar(speed);
  const next = obj.position.clone().addScaledVector(vel, dt);

  const fi = currentFloorIndexFromY(next.y);
  next.y = fi * floorHeight;

  obj.position.copy(resolveCollisions(next));

  floorEl.textContent = `FLOOR: ${fi+1}`;
  mapFloorEl.textContent = `MAP: FLOOR ${fi+1}`;
}

/* =========================
   EMP (ALL GUARDS, ALL FLOORS) + SFX
========================= */
let empLeft = EMP_MAX;
let empCooldownT = 0;

function updateEmpHud(){
  empHud.textContent = `EMP: ${empLeft}${empCooldownT>0 ? " (cool)" : ""}`;
}

function empPulseAt(position, color=0x4af2c5){
  const ring = new THREE.Mesh(
    new THREE.RingGeometry(0.4, 0.55, 48),
    new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.85, side:THREE.DoubleSide })
  );
  ring.rotation.x = -Math.PI/2;
  ring.position.copy(position);
  ring.position.y += 0.08;
  scene.add(ring);

  let t = 0;
  const tick = (dt)=>{
    t += dt;
    const s = 1 + t*7.2;
    ring.scale.set(s,s,s);
    ring.material.opacity = Math.max(0, 0.85 - t*1.1);
    if(t > 0.8){
      scene.remove(ring);
      ring.geometry.dispose();
      ring.material.dispose();
      return true;
    }
    return false;
  };
  return tick;
}

let empPulseTick = null;

function useEMP(){
  if(state !== "infiltrate") return;
  if(empLeft <= 0) { showHint("EMP 소진", true); setTimeout(()=>showHint("",false), 450); return; }
  if(empCooldownT > 0) return;

  empLeft -= 1;
  empCooldownT = EMP_COOLDOWN;
  updateEmpHud();

  sfxEMP(); // ✅ sound

  const now = performance.now()/1000;

  for(const g of guards){
    g.stunnedUntil = Math.max(g.stunnedUntil, now + EMP_STUN_SEC);

    const mats = g.obj.userData.mats || [];
    for(const m of mats){
      if(!m) continue;
      m.emissive = new THREE.Color(0x4af2c5);
      m.emissiveIntensity = 0.75;
    }
    const pl = g.obj.userData.glowLight;
    if(pl){ pl.color.set(0x4af2c5); pl.intensity = 0.9; }
  }

  const pobj = controls.getObject();
  const fi = currentFloorIndexFromY(pobj.position.y);
  const info = floorInfos[fi];
  empPulseTick = empPulseAt(new THREE.Vector3(pobj.position.x, info.yBase, pobj.position.z), 0x4af2c5);

  showHint(`EMP 방출: 전 경비 ${EMP_STUN_SEC.toFixed(0)}초 정지`, true);
  setTimeout(()=>showHint("",false), 700);
}

/* =========================
   Guards update + death
========================= */
function updateGuards(dt){
  const pobj = controls.getObject();
  const playerFi = currentFloorIndexFromY(pobj.position.y);
  const info = floorInfos[playerFi];
  const playerCell = worldToCell(pobj.position);
  const playerWorld = pobj.position;

  const now = performance.now()/1000;
  let maxAlert = 0;

  for(const g of guards){
    const active = (g.floor === playerFi);

    g.bob += dt * 3.2;
    g.obj.position.y = (g.floor*floorHeight) + (Math.sin(g.bob)*0.045);

    if(active){
      const stunned = (g.stunnedUntil > now);

      if(!stunned){
        g.repathT -= dt;
        if(g.repathT <= 0 || g.path.length === 0){
          const startCell = worldToCell(g.obj.position);
          g.path = aStar(info.grid, startCell, playerCell);
          g.pathI = 0;
          g.repathT = 0.22;
        }

        if(g.path.length >= 2){
          const nextI = Math.min(g.pathI + 1, g.path.length - 1);
          const tgtCell = g.path[nextI];
          const tgt = cellToWorld(tgtCell.x, tgtCell.y, info.yBase);

          const to = tgt.clone().sub(g.obj.position);
          to.y = 0;
          const dist = to.length();

          if(dist < 0.10){
            g.pathI = nextI;
          }else{
            const step = Math.min(dist, g.speed * dt);
            g.obj.position.addScaledVector(to.normalize(), step);
            const yaw = Math.atan2(to.x, to.z);
            g.obj.rotation.y = yaw;
          }
        }

        const d = distxz(g.obj.position, playerWorld);
        const near = d < 9.0;
        g.alert = clamp01(g.alert + dt*(near ? 1.05 : 0.65));

        if(d < DEATH_DIST){
          onCaughtByGuard();
          return;
        }

        const mats = g.obj.userData.mats || [];
        for(const m of mats){
          if(!m) continue;
          m.emissive = new THREE.Color(0xff4b81);
          m.emissiveIntensity = 0.08 + 0.55 * g.alert;
        }
        const pl = g.obj.userData.glowLight;
        if(pl){ pl.color.set(0xff4b81); pl.intensity = 0.55 + 0.25*g.alert; }

      }else{
        g.alert = clamp01(g.alert - dt*0.9);
        g.obj.rotation.y += dt*0.45;
        const mats = g.obj.userData.mats || [];
        for(const m of mats){
          if(!m) continue;
          m.emissive = new THREE.Color(0x4af2c5);
          m.emissiveIntensity = 0.55 + 0.25*Math.sin(now*14);
        }
        const pl = g.obj.userData.glowLight;
        if(pl){ pl.color.set(0x4af2c5); pl.intensity = 0.8 + 0.2*Math.sin(now*14); }
      }

    }else{
      g.alert = clamp01(g.alert - dt*0.7);
      g.obj.rotation.y += dt*0.15;
    }

    maxAlert = Math.max(maxAlert, g.alert);
  }

  globalAlert = clamp01(Math.max(globalAlert - dt*0.08, maxAlert));
  alertEl.textContent = `ALERT: ${Math.round(globalAlert*100)}%`;
  if(state==="infiltrate"){
    statusEl.textContent = (globalAlert > 0.98) ? "STATUS: 경보!" : "STATUS: 침투";
  }
}

/* =========================
   Minimap
========================= */
function drawMinimap(){
  const pobj = controls.getObject();
  const fi = currentFloorIndexFromY(pobj.position.y);
  const info = floorInfos[fi];
  const grid = info.grid;

  const W = mapCanvas.width, H = mapCanvas.height;
  mapCtx.clearRect(0,0,W,H);

  mapCtx.fillStyle = "rgba(6,8,18,0.80)";
  mapCtx.fillRect(0,0,W,H);

  const cellPx = Math.floor(Math.min(W / gridW, H / gridH));
  const offsetX = Math.floor((W - cellPx*gridW)/2);
  const offsetY = Math.floor((H - cellPx*gridH)/2);

  mapCtx.fillStyle = "rgba(180,200,255,0.22)";
  for(let y=0;y<gridH;y++){
    for(let x=0;x<gridW;x++){
      if(grid[y][x]===1){
        mapCtx.fillRect(offsetX + x*cellPx, offsetY + y*cellPx, cellPx, cellPx);
      }
    }
  }

  const goal = (fi < floors-1) ? info.exitPos : info.bombPos;
  if(goal){
    const gc = worldToCell(goal);
    mapCtx.fillStyle = "rgba(255,209,102,0.95)";
    mapCtx.beginPath();
    mapCtx.arc(offsetX + (gc.x+0.5)*cellPx, offsetY + (gc.y+0.5)*cellPx, Math.max(3, cellPx*0.32), 0, Math.PI*2);
    mapCtx.fill();
  }

  mapCtx.fillStyle = "rgba(255,75,129,0.98)";
  for(const g of guards){
    if(g.floor !== fi) continue;
    const c = worldToCell(g.obj.position);
    mapCtx.beginPath();
    mapCtx.arc(offsetX + (c.x+0.5)*cellPx, offsetY + (c.y+0.5)*cellPx, Math.max(3, cellPx*0.30), 0, Math.PI*2);
    mapCtx.fill();
  }

  const pc = worldToCell(pobj.position);
  mapCtx.fillStyle = "rgba(74,242,197,0.98)";
  mapCtx.beginPath();
  mapCtx.arc(offsetX + (pc.x+0.5)*cellPx, offsetY + (pc.y+0.5)*cellPx, Math.max(3, cellPx*0.32), 0, Math.PI*2);
  mapCtx.fill();

  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  dir.y = 0; dir.normalize();
  const angle = Math.atan2(dir.x, dir.z);
  const px = offsetX + (pc.x+0.5)*cellPx;
  const py = offsetY + (pc.y+0.5)*cellPx;
  const r = Math.max(6, cellPx*0.55);
  mapCtx.strokeStyle = "rgba(74,242,197,0.85)";
  mapCtx.lineWidth = 2;
  mapCtx.beginPath();
  mapCtx.moveTo(px,py);
  mapCtx.lineTo(px + Math.sin(angle)*r, py + Math.cos(angle)*r);
  mapCtx.stroke();

  mapCtx.strokeStyle = "rgba(160,190,255,0.35)";
  mapCtx.lineWidth = 1;
  mapCtx.strokeRect(0.5,0.5,W-1,H-1);
}

/* =========================
   Messages / Endings
========================= */
let state = "infiltrate"; // infiltrate | countdown | dead
let countdownT = 0;
let endTimer = 0;
let caughtOnce = false;

function htmlize(msg){
  const safe = msg.split("\n").map(l=> l.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;"));
  const html = safe.map(l=>{
    if(l.includes("**재와 그림자**")){
      return l.replace("**재와 그림자**", `<span class="redBlink">재와 그림자</span>`);
    }
    return l;
  }).join("\n");
  return html;
}

function showOverlay(text){
  msgText.innerHTML = htmlize(text);
  msgOverlay.style.opacity = "1";
}
function hideOverlay(){ msgOverlay.style.opacity = "0"; }

function MSG_MISSION_OVER(){
  return `[SECURE CHANNEL OVERRIDDEN]

당신의 임무는 종료되었습니다.

귀하는 본 작전에 투입된
소모 자산(Expendable Asset)입니다.

본 시설 및 임무 기록은
몇 분 후 완전히 삭제됩니다.

탈출 경로: 제공되지 않음.

곧 이곳에는
**재와 그림자**만 남을 것입니다.`;
}

function MSG_CAUGHT(){
  return `[KOROLYOV V2 / SECURITY]

표적: 침입자
식별: 미승인

대응 프로토콜:
- 접근 차단
- 신경 억제(비치명 설정: OFF)
- 증거 소각 절차: 승인

결과:
표적 제거 완료.`;
}

function tryUseE(){
  if(state !== "infiltrate") return;
  const obj = controls.getObject();
  const fi = currentFloorIndexFromY(obj.position.y);
  const info = floorInfos[fi];

  if(fi === floors-1 && info.bombPos){
    if(dist2xz(obj.position, info.bombPos) <= info.bombRadius*info.bombRadius){
      placeBombAndEnd();
      return;
    }
  }
  if(fi < floors-1){
    if(dist2xz(obj.position, info.exitPos) <= info.exitRadius*info.exitRadius){
      const nextInfo = floorInfos[fi+1];
      obj.position.copy(nextInfo.entrancePos.clone().add(new THREE.Vector3(2.2, 0, 0)));
      obj.position.y = nextInfo.yBase;
      showHint(`층 ${fi+2} 진입`, true);
      setTimeout(()=>showHint("",false), 650);
    }
  }
}
window.addEventListener("keydown", (e)=>{ if(e.code==="KeyE") tryUseE(); });

function updateHints(){
  if(state!=="infiltrate"){ showHint("", false); return; }
  const obj = controls.getObject();
  const fi = currentFloorIndexFromY(obj.position.y);
  const info = floorInfos[fi];

  if(fi < floors-1){
    if(dist2xz(obj.position, info.exitPos) <= info.exitRadius*info.exitRadius){ showHint("E: 위층으로 이동", true); return; }
  }else{
    if(dist2xz(obj.position, info.bombPos) <= info.bombRadius*info.bombRadius){ showHint("E: 폭탄 설치", true); return; }
  }
  showHint("", false);
}

function placeBombAndEnd(){
  state = "countdown";
  countdownT = 6.5;
  statusEl.textContent = "STATUS: 임무 종료";
  showOverlay(MSG_MISSION_OVER());
  sfxMissionOver(); // ✅ sound
  const last = floorInfos[floors-1];
  if(last.bombMarker) last.bombMarker.material.color.set(0xff4b81);
}

function onCaughtByGuard(){
  if(caughtOnce) return;
  caughtOnce = true;

  showOverlay(MSG_CAUGHT());
  sfxCaught(); // ✅ sound

  state = "dead";
  statusEl.textContent = "STATUS: 제거됨";
  endH.innerHTML = `경비 프로토콜에 의해 <span class="redBlink">제거</span>되었습니다.`;
  endP.textContent = "EMP는 제한적입니다. 경로를 끊고, 시야 밖에서 움직이세요.\nR 키로 다시 시작.";

  setTimeout(()=>{
    hideOverlay();
    fade.style.opacity = "1";
    endTimer = 0;
    controls.unlock();
  }, 850);
}

function triggerAshEnding(){
  state = "dead";
  hideOverlay();
  fade.style.opacity = "1";
  endTimer = 0;
  endH.innerHTML = `…몇 분 후, 이곳에는 <span class="redBlink">재와 그림자</span>만 남았습니다.`;
  endP.textContent = "즉사 엔딩(프로토타입).\nR 키로 다시 시작할 수 있습니다.";
  controls.unlock();
}

function updateCountdown(dt){
  if(state !== "countdown") return;
  countdownT -= dt;
  statusEl.textContent = `STATUS: 말소까지 ${Math.max(0, Math.ceil(countdownT))}s`;
  if(countdownT <= 0) triggerAshEnding();
}
function updateDeath(dt){
  if(state !== "dead") return;
  endTimer += dt;
  if(endTimer > 1.25) endTitle.style.opacity = "1";
}

/* =========================
   Start / reset
========================= */
btn.addEventListener("click", ()=>{
  lockScreen.style.display = "none";
  ensureAudio();              // ✅ audio unlocked on user gesture
  if(audioCtx?.state === "suspended") audioCtx.resume();
  if(!isMobile) controls.lock();
});

controls.addEventListener("unlock", ()=>{
  if(state !== "dead" && !isMobile) lockScreen.style.display = "flex";
});

function resetRun(){
  state = "infiltrate";
  countdownT = 0;
  endTimer = 0;
  caughtOnce = false;

  globalAlert = 0;
  alertEl.textContent = "ALERT: 0%";
  statusEl.textContent = "STATUS: 침투";

  hideOverlay();
  fade.style.opacity = "0";
  endTitle.style.opacity = "0";

  empLeft = EMP_MAX;
  empCooldownT = 0;
  updateEmpHud();

  const last = floorInfos[floors-1];
  if(last?.bombMarker) last.bombMarker.material.color.set(0xffd166);

  const start = floorInfos[0].entrancePos.clone().add(new THREE.Vector3(2.2, 0, 0));
  controls.getObject().position.copy(start);
  controls.getObject().position.y = 0;

  spawnGuardsExact();
  lockScreen.style.display = "flex";
}

/* =========================
   Stars
========================= */
const stars = new THREE.Points(
  new THREE.BufferGeometry(),
  new THREE.PointsMaterial({ color:0xc7d3ff, size:0.03, transparent:true, opacity:0.55 })
);
{
  const N=900;
  const arr = new Float32Array(N*3);
  for(let i=0;i<N;i++){
    const r = 90 + Math.random()*200;
    const th = Math.random()*Math.PI*2;
    const ph = Math.acos(THREE.MathUtils.randFloatSpread(2));
    arr[i*3+0] = Math.cos(th)*Math.sin(ph)*r;
    arr[i*3+1] = Math.cos(ph)*r + 50;
    arr[i*3+2] = Math.sin(th)*Math.sin(ph)*r;
  }
  stars.geometry.setAttribute("position", new THREE.BufferAttribute(arr,3));
}
scene.add(stars);

/* =========================
   Resize
========================= */
window.addEventListener("resize", ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});

/* =========================
   Guards update loop glue + supercomputer animate
========================= */
let last = performance.now();
let empPulseTickLocal = null;

let empLeftLocalRef = null; // unused (kept for stability)

function tick(nowMs){
  const dt = Math.min(0.033, (nowMs-last)/1000);
  last = nowMs;

  // supercomputer sprite subtle flicker/hover
  if(superComputerSprite){
    superComputerSprite.material.opacity = 0.92 + 0.06*Math.sin(nowMs*0.006);
    superComputerSprite.position.y += Math.sin(nowMs*0.004)*0.0008;
    const hl = superComputerSprite.userData.holoLight;
    if(hl) hl.intensity = 0.85 + 0.22*Math.sin(nowMs*0.007);
  }

  if(empPulseTick){
    const done = empPulseTick(dt);
    if(done) empPulseTick = null;
  }
  if(empCooldownT > 0){
    empCooldownT = Math.max(0, empCooldownT - dt);
    updateEmpHud();
  }

  if(state !== "dead"){
    updatePlayer(dt);
    updateGuards(dt);
    updateHints();
    updateCountdown(dt);
  }else{
    updateDeath(dt);
  }

  drawMinimap();
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}

/* Boot */
resetRun();
requestAnimationFrame(tick);
</script>
</body>
</html>
